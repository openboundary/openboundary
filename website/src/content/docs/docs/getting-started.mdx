---
title: Getting Started
description: Install OpenBoundary and compile your first specification.
---

This guide walks you through installing OpenBoundary and generating your first TypeScript backend.

## Prerequisites

- **Node.js 18+** — For running generated code
- **Go 1.21+** — For building the CLI (or use the install script)
- **PostgreSQL** — If using database components

## Installation

### Install Script (Recommended)

```bash
curl -fsSL https://openboundary.org/install.sh | sh
```

This installs the `bound` CLI to `~/.local/bin/`.

### With Go

```bash
go install github.com/openboundary/openboundary/cmd/bound@latest
```

### Verify Installation

```bash
bound --version
# openboundary v0.1.0
```

## Create Your First Project

We'll build a simple CRM API with contacts and companies.

### 1. Initialize

Generate a starter project:

```bash
bound init basic -o crm-api
cd crm-api
```

This creates:

```
crm-api/
├── spec.yaml           # OpenBoundary specification
├── openapi.yaml        # API contract
└── src/
    ├── auth/
    │   ├── auth.config.ts   # Authentication config
    │   ├── model.conf       # Authorization model
    │   └── policy.csv       # Authorization policies
    └── db/
        └── schema.ts        # Database schema
```

### 2. Define the Spec

Edit `spec.yaml` to define your CRM API:

```yaml
version: "0.1.0"
name: crm-api

components:
  # Database
  - id: postgres.primary
    kind: postgres
    spec:
      provider: drizzle
      schema: ./src/db/schema.ts

  # Authentication middleware
  - id: middleware.authn
    kind: middleware
    spec:
      provider: better-auth
      config: ./src/auth/auth.config.ts

  # Authorization middleware
  - id: middleware.authz
    kind: middleware
    spec:
      provider: casbin
      model: ./src/auth/model.conf
      policy: ./src/auth/policy.csv
      depends_on:
        - middleware.authn

  # HTTP Server
  - id: http.server.api
    kind: http.server
    spec:
      framework: hono
      port: 3000
      openapi: ./openapi.yaml
      middleware:
        - middleware.authn
        - middleware.authz
      depends_on:
        - postgres.primary

  # Contacts
  - id: usecase.list-contacts
    kind: usecase
    spec:
      binds_to: http.server.api:GET:/contacts
      goal: List all contacts for the current user

  - id: usecase.create-contact
    kind: usecase
    spec:
      binds_to: http.server.api:POST:/contacts
      goal: Create a new contact

  - id: usecase.get-contact
    kind: usecase
    spec:
      binds_to: http.server.api:GET:/contacts/{id}
      goal: Get contact details

  # Companies
  - id: usecase.list-companies
    kind: usecase
    spec:
      binds_to: http.server.api:GET:/companies
      goal: List all companies
```

### 3. Compile

Generate TypeScript code:

```bash
bound compile spec.yaml
```

Output:

```
✓ Validated specification
✓ Validated security boundaries
✓ Enforced middleware invariants
✓ Generated TypeScript project

Output: ./generated/
  → src/server.ts
  → src/middleware/authn.ts
  → src/middleware/authz.ts
  → src/components/usecases/usecase-list-contacts.ts
  → src/components/usecases/usecase-create-contact.ts
  → src/components/usecases/usecase-get-contact.ts
  → src/components/usecases/usecase-list-companies.ts
  → src/types.ts
```

### 4. Implement Business Logic

Open a generated usecase file:

```typescript
// generated/src/components/usecases/usecase-list-contacts.ts
// Generated by OpenBoundary - DO NOT EDIT

export async function listContacts(
  c: Context
): Promise<ListContactsResponse> {
  // TODO: Implement usecase
  throw new Error('Not implemented');
}
```

Implement the handler:

```typescript
export async function listContacts(
  c: Context
): Promise<ListContactsResponse> {
  const db = c.get('postgres.primary');
  const user = c.get('user'); // Injected by authn middleware

  const contacts = await db
    .select()
    .from(contactsTable)
    .where(eq(contactsTable.ownerId, user.id));

  return c.json({ contacts });
}
```

:::caution
Only edit the function body. Imports, signatures, and types are regenerated on compile.
:::

### 5. Run

Set up your database and start the server:

```bash
cd generated

# Set database connection
export DATABASE_URL="postgresql://user:pass@localhost:5432/mydb"

# Install dependencies
npm install

# Start development server
npm run dev
```

The server starts at `http://localhost:3000`.

## What's Generated

| Directory | Contents | Editable |
|-----------|----------|----------|
| `src/server.ts` | Hono app, routing, middleware | No |
| `src/middleware/*.ts` | Auth integration | No |
| `src/components/usecases/*.ts` | Handler stubs | Body only |
| `src/types.ts` | TypeScript types from OpenAPI | No |

## Development Workflow

```
┌─────────────────┐     ┌──────────────┐     ┌─────────────────┐
│  Edit spec.yaml │ --> │ bound compile│ --> │ Generated Code  │
│  or openapi.yaml│     │              │     │ (infrastructure)│
└─────────────────┘     └──────────────┘     └─────────────────┘
                                                     │
                                                     v
                                             ┌─────────────────┐
                                             │ Implement logic │
                                             │ (usecase bodies)│
                                             └─────────────────┘
```

1. **Define architecture** in `spec.yaml`
2. **Define API contract** in `openapi.yaml`
3. **Compile** to generate infrastructure
4. **Implement** business logic in usecase bodies
5. **Repeat** as requirements change

## Next Steps

- [Schema Reference](/docs/reference/schema) — Complete field documentation
- [Component Catalog](/docs/components/) — All component types
- [CLI Reference](/docs/reference/cli) — All commands and options
- [Troubleshooting](/docs/reference/troubleshooting) — Common errors and fixes
