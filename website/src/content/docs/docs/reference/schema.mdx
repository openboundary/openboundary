---
title: Schema Reference
description: Complete field reference for OpenBoundary specification files.
---

This document provides a complete reference for all fields in an OpenBoundary specification file.

## Specification Root

Every `spec.yaml` file must contain these top-level fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `version` | string | Yes | Specification version. Must be semver format: `x.y.z` |
| `name` | string | Yes | Project name. Must be kebab-case: `^[a-z][a-z0-9-]*$` |
| `description` | string | No | Human-readable project description |
| `components` | array | Yes | List of component definitions |

```yaml
version: "0.1.0"
name: my-api
description: User management API
components: []
```

## Component Structure

Every component has three required fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | Yes | Unique identifier in dot-notation |
| `kind` | string | Yes | Component type (see below) |
| `spec` | object | Yes | Component-specific configuration |

### Component ID Format

IDs must match: `^[a-z][a-z0-9-]*(\.[a-z][a-z0-9-]*)+$`

**Valid examples:**
- `http.server.api`
- `middleware.authn`
- `postgres.primary`
- `usecase.create-user`

**Invalid examples:**
- `server` (needs at least one dot)
- `HTTP.Server` (uppercase not allowed)
- `http_server.api` (underscores not allowed)

### Component Kinds

| Kind | Description |
|------|-------------|
| `http.server` | HTTP server with routing and middleware |
| `middleware` | Authentication or authorization middleware |
| `postgres` | PostgreSQL database connection |
| `usecase` | Business logic bound to a route |

---

## http.server

HTTP server component that generates routing and middleware integration.

### Fields

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `framework` | string | Yes | — | Web framework. Currently only `hono` |
| `port` | integer | Yes | — | Port number. Range: 1-65535 |
| `openapi` | string | No | — | Path to OpenAPI spec. Must start with `./` |
| `middleware` | array | No | `[]` | Middleware chain in execution order |
| `depends_on` | array | No | `[]` | Components available for dependency injection |

### Example

```yaml
- id: http.server.api
  kind: http.server
  spec:
    framework: hono
    port: 3000
    openapi: ./openapi.yaml
    middleware:
      - middleware.authn
      - middleware.authz
    depends_on:
      - postgres.primary
```

### Field Details

#### `framework`

Currently only `hono` is supported. Planned: `fastify`, `chi` (Go).

#### `port`

Must be a valid port number (1-65535). Common values:
- `3000` - Development
- `8080` - Production
- `443` - HTTPS (requires reverse proxy)

#### `openapi`

Path to OpenAPI 3.x specification file. The compiler uses this for:
- Route definitions
- Request/response type generation
- Input validation schemas

Must be a relative path starting with `./`:
```yaml
openapi: ./openapi.yaml      # Valid
openapi: openapi.yaml        # Invalid - must start with ./
openapi: /abs/path.yaml      # Invalid - no absolute paths
```

#### `middleware`

Array of middleware component references. Order matters—middleware executes in the order listed:

```yaml
middleware:
  - middleware.authn    # Runs first
  - middleware.authz    # Runs second
```

Empty array means no middleware:
```yaml
middleware: []  # Server has no default middleware
```

#### `depends_on`

Components that can be injected into route handlers:

```yaml
depends_on:
  - postgres.primary    # Database available as ctx.get('postgres.primary')
  - redis.cache         # Cache available as ctx.get('redis.cache')
```

### Generated Output

```
src/
├── server.ts           # Hono app with middleware wiring
├── routes/
│   └── *.ts            # Route handlers from OpenAPI
├── middleware/
│   └── *.ts            # Middleware integrations
└── types.ts            # TypeScript types from OpenAPI
```

---

## middleware

Middleware component for authentication or authorization.

### Fields

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `provider` | string | Yes | — | Middleware provider: `better-auth` or `casbin` |
| `config` | string | Conditional | — | Path to config file. Required for `better-auth` |
| `model` | string | Conditional | — | Path to Casbin model. Required for `casbin` |
| `policy` | string | Conditional | — | Path to Casbin policy. Required for `casbin` |
| `depends_on` | array | No | `[]` | Middleware that must run before this one |

### Provider: better-auth

Authentication middleware using [better-auth](https://better-auth.com).

```yaml
- id: middleware.authn
  kind: middleware
  spec:
    provider: better-auth
    config: ./src/auth/auth.config.ts
```

**Required fields:** `provider`, `config`

The config file must export a better-auth configuration:

```typescript
// src/auth/auth.config.ts
import { betterAuth } from 'better-auth';

export const auth = betterAuth({
  database: { /* ... */ },
  emailAndPassword: { enabled: true },
});
```

### Provider: casbin

Authorization middleware using [Casbin](https://casbin.org).

```yaml
- id: middleware.authz
  kind: middleware
  spec:
    provider: casbin
    model: ./src/auth/model.conf
    policy: ./src/auth/policy.csv
    depends_on:
      - middleware.authn  # Auth must run first
```

**Required fields:** `provider`, `model`, `policy`

**Model file** (RBAC example):
```ini
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
```

**Policy file:**
```csv
p, admin, /users, DELETE
p, user, /users, GET
g, alice, admin
g, bob, user
```

### Field Details

#### `depends_on`

For middleware, `depends_on` specifies execution order. Authorization typically depends on authentication:

```yaml
- id: middleware.authz
  kind: middleware
  spec:
    provider: casbin
    model: ./src/auth/model.conf
    policy: ./src/auth/policy.csv
    depends_on:
      - middleware.authn  # User must be authenticated first
```

This ensures `middleware.authn` always runs before `middleware.authz`.

---

## postgres

PostgreSQL database component using Drizzle ORM.

### Fields

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `provider` | string | Yes | — | Database provider. Currently only `drizzle` |
| `schema` | string | Yes | — | Path to Drizzle schema file. Must start with `./` |

### Example

```yaml
- id: postgres.primary
  kind: postgres
  spec:
    provider: drizzle
    schema: ./src/db/schema.ts
```

### Schema File

The schema file must export Drizzle table definitions:

```typescript
// src/db/schema.ts
import { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: text('email').notNull().unique(),
  name: text('name'),
  createdAt: timestamp('created_at').defaultNow(),
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  authorId: serial('author_id').references(() => users.id),
});
```

### Environment Variables

The generated code expects `DATABASE_URL`:

```bash
DATABASE_URL=postgresql://user:pass@localhost:5432/mydb
```

### Injection

When a server depends on a postgres component, handlers receive it via context:

```typescript
export async function getUsers(c: Context) {
  const db = c.get('postgres.primary');
  const users = await db.select().from(usersTable);
  return c.json(users);
}
```

---

## usecase

Business logic component bound to an HTTP route.

### Fields

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `binds_to` | string | Yes | — | Route binding: `server:METHOD:/path` |
| `goal` | string | Yes | — | What this usecase accomplishes |
| `middleware` | array | No | (inherited) | Middleware for this endpoint |
| `actor` | string | No | — | Who performs this action |
| `preconditions` | array | No | `[]` | Conditions required before execution |
| `acceptance_criteria` | array | No | `[]` | Success criteria |
| `postconditions` | array | No | `[]` | Conditions true after execution |

### Example

```yaml
- id: usecase.create-user
  kind: usecase
  spec:
    binds_to: http.server.api:POST:/users
    goal: Register a new user account
    actor: Anonymous visitor
    middleware: []  # Public endpoint
    preconditions:
      - Email is not already registered
    acceptance_criteria:
      - User record created in database
      - Confirmation email sent
    postconditions:
      - User can log in with credentials
```

### Field Details

#### `binds_to`

Route binding format: `{server-id}:{METHOD}:{path}`

Pattern: `^[a-z][a-z0-9-]*(\.[a-z][a-z0-9-]*)+:(GET|POST|PUT|PATCH|DELETE):/[a-zA-Z0-9/{}_-]*$`

**Valid examples:**
```yaml
binds_to: http.server.api:GET:/users
binds_to: http.server.api:POST:/users
binds_to: http.server.api:GET:/users/{id}
binds_to: http.server.api:DELETE:/users/{id}
binds_to: http.server.admin:PUT:/settings
```

**Invalid examples:**
```yaml
binds_to: api:GET:/users           # Server ID needs dots
binds_to: http.server.api:get:/users  # Method must be uppercase
binds_to: http.server.api:GET:users   # Path must start with /
binds_to: http.server.api:GET:/users?limit=10  # No query strings
```

**Path parameters** use curly braces:
```yaml
binds_to: http.server.api:GET:/users/{id}
binds_to: http.server.api:GET:/users/{userId}/posts/{postId}
```

#### `middleware`

Controls middleware for this specific endpoint:

| Value | Behavior |
|-------|----------|
| Omit field | Inherits server's full middleware chain |
| `[]` (empty array) | No middleware (public endpoint) |
| `[middleware.authn]` | Only listed middleware |

```yaml
# Inherits all server middleware
- id: usecase.get-profile
  kind: usecase
  spec:
    binds_to: http.server.api:GET:/profile
    goal: Get current user profile
    # middleware field omitted = full chain

# Public endpoint
- id: usecase.signup
  kind: usecase
  spec:
    binds_to: http.server.api:POST:/signup
    goal: Create new account
    middleware: []  # No auth required

# Subset of middleware
- id: usecase.public-posts
  kind: usecase
  spec:
    binds_to: http.server.api:GET:/posts
    goal: List public posts
    middleware:
      - middleware.rate-limit  # Rate limit but no auth
```

#### `goal`

Human-readable description of what the usecase does. Used for:
- Documentation generation
- AI agent context
- Code comments

```yaml
goal: Register a new user account and send welcome email
```

#### `actor`

Who performs this action. Useful for documentation and access control design:

```yaml
actor: Authenticated user
actor: Admin
actor: Anonymous visitor
actor: System (scheduled job)
```

#### `preconditions`, `acceptance_criteria`, `postconditions`

These fields document behavior and can generate test scaffolding:

```yaml
preconditions:
  - User is authenticated
  - User has admin role
  - Target user exists

acceptance_criteria:
  - User record is deleted
  - Associated posts are deleted
  - Audit log entry created

postconditions:
  - User cannot log in
  - User email is available for new registration
```

### Generated Output

Each usecase generates a handler file:

```typescript
// src/components/usecases/usecase-create-user.ts
// Generated by OpenBoundary - DO NOT EDIT

import type { Context } from 'hono';
import type { CreateUserRequest, CreateUserResponse } from '../schemas';

/**
 * Register a new user account
 * Actor: Anonymous visitor
 *
 * Preconditions:
 * - Email is not already registered
 *
 * Acceptance Criteria:
 * - User record created in database
 * - Confirmation email sent
 */
export async function createUser(
  c: Context,
  input: CreateUserRequest
): Promise<CreateUserResponse> {
  // TODO: Implement usecase
  throw new Error('Not implemented');
}
```

---

## Component References

Many fields reference other components. References must match an existing component ID.

### Valid Reference Targets

| Field | Can Reference |
|-------|---------------|
| `http.server.middleware` | `middleware.*` components |
| `http.server.depends_on` | `postgres.*`, `redis.*`, other infrastructure |
| `middleware.depends_on` | Other `middleware.*` components |
| `usecase.binds_to` | `http.server.*` components |
| `usecase.middleware` | `middleware.*` components |

### Validation

The compiler validates that all references point to existing components:

```yaml
components:
  - id: http.server.api
    kind: http.server
    spec:
      framework: hono
      port: 3000
      middleware:
        - middleware.authn  # ERROR if middleware.authn doesn't exist
```

---

## File Paths

File paths must be relative and start with `./`:

```yaml
openapi: ./openapi.yaml        # Valid
schema: ./src/db/schema.ts     # Valid
config: ../auth.ts             # Invalid - no parent traversal
policy: /etc/casbin/policy.csv # Invalid - no absolute paths
```

The compiler resolves paths relative to the spec file location.

---

## Complete Example

```yaml
version: "0.1.0"
name: user-api
description: User management API with authentication

components:
  # Database
  - id: postgres.primary
    kind: postgres
    spec:
      provider: drizzle
      schema: ./src/db/schema.ts

  # Authentication
  - id: middleware.authn
    kind: middleware
    spec:
      provider: better-auth
      config: ./src/auth/auth.config.ts

  # Authorization
  - id: middleware.authz
    kind: middleware
    spec:
      provider: casbin
      model: ./src/auth/model.conf
      policy: ./src/auth/policy.csv
      depends_on:
        - middleware.authn

  # HTTP Server
  - id: http.server.api
    kind: http.server
    spec:
      framework: hono
      port: 3000
      openapi: ./openapi.yaml
      middleware:
        - middleware.authn
        - middleware.authz
      depends_on:
        - postgres.primary

  # Public endpoint
  - id: usecase.signup
    kind: usecase
    spec:
      binds_to: http.server.api:POST:/signup
      goal: Register a new user
      middleware: []

  # Protected endpoint
  - id: usecase.get-profile
    kind: usecase
    spec:
      binds_to: http.server.api:GET:/profile
      goal: Get current user profile

  # Admin endpoint
  - id: usecase.delete-user
    kind: usecase
    spec:
      binds_to: http.server.api:DELETE:/users/{id}
      goal: Delete a user account
      actor: Admin
      middleware:
        - middleware.authn
        - middleware.authz
```
