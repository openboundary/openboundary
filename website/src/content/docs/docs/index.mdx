---
title: Introduction
description: Architectural guardrails for AI-assisted backend development.
---

OpenBoundary is a specification compiler. You define architectural constraints in YAML—authentication, authorization, database schemas, route bindings—and the compiler generates type-safe TypeScript that enforces those constraints.

```bash
bound compile spec.yaml
```

The generated code wires up middleware chains, injects dependencies, and creates handler stubs. You implement business logic. The architecture stays locked.

---

## The Problem

AI code generation speeds up development but introduces consistency risks. Without constraints, generated code may skip middleware, bypass authentication, or violate schema contracts.

The root cause: architectural decisions live in your head, scattered across code comments, buried in documentation that drifts from implementation.

---

## How OpenBoundary Works

**Separate what changes rarely from what changes constantly.**

| Boundaries | Logic |
|------------|-------|
| Auth, routing, middleware, schemas | Business rules, handlers, domain operations |
| Structural — change rarely, review carefully | Behavioral — change constantly as requirements evolve |
| Defined in `spec.yaml` | Implemented in handler functions |

You define boundaries in specs. AI (or you) implements logic in handlers. Regenerate anytime—boundaries are enforced, logic is preserved.

---

## Standards, Not Lock-in

Your spec references existing ecosystem tools in their native formats:

- **OpenAPI** for routes and request/response schemas
- **Drizzle** for database structure
- **Casbin** for authorization policies
- **better-auth** for authentication

No proprietary formats. OpenBoundary orchestrates standards you already use.

---

## Next Steps

- **[Quick Start](/docs/getting-started)** — Install and compile your first spec
- **[Templates](/docs/templates)** — Pre-built specs for common patterns
- **[Components](/docs/components)** — HTTP servers, databases, middleware

:::note
A TypeScript DSL for defining specs programmatically is planned. Same boundaries, better ergonomics for complex configurations.
:::
