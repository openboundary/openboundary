---
title: Documentation
description: Define components in YAML, generate type-safe TypeScript backends.
---

Define components in YAML, generate type-safe TypeScript backends.

## Philosophy

AI code generation speeds up development but introduces architectural consistency risks. Without constraints, generated code may skip middleware, bypass authentication checks, or violate schema contracts.

The root cause: architectural decisions live in your head, scattered across code comments, and buried in documentation that drifts from implementation.

**OpenBoundary separates architectural constraints from implementation logic.** Security requirements, middleware chains, database schemas, and route bindings are declared in a machine-readable specification. The compiler validates these constraints and enforces them in generated code. You define invariants once; the compiler ensures they hold.

### Boundaries vs. Logic

Software has two parts that change at different rates:

- **Boundaries** — auth, routing, middleware, database schemas. These are structural. They change rarely and require careful review when they do.
- **Logic** — business rules, handlers, domain operations. These are behavioral. They change constantly as requirements evolve.

OpenBoundary separates these concerns. You define boundaries in specs. AI (or you) implements logic in handlers. Regenerate anytime—your boundaries are enforced, your logic is preserved.

### Specification-First Development

Your spec references existing ecosystem tools in their native formats:

- **OpenAPI** for HTTP routes and request/response schemas
- **Drizzle schemas** for database structure
- **Casbin policies** for authorization rules
- **better-auth configs** for authentication

No lock-in. No proprietary formats. OpenBoundary orchestrates standards you already use.

:::note
**Future:** A TypeScript DSL for defining specs programmatically. Same boundaries, better ergonomics for complex configurations.
:::
