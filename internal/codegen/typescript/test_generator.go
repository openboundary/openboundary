// Copyright 2026 Open Boundary Contributors
// SPDX-License-Identifier: AGPL-3.0-or-later

package typescript

import (
	"fmt"
	"sort"
	"strings"

	"github.com/openboundary/openboundary/internal/codegen"
	"github.com/openboundary/openboundary/internal/ir"
)

// TestGenerator generates Vitest test files for generated TypeScript code.
type TestGenerator struct{}

// NewTestGenerator creates a new test generator.
func NewTestGenerator() *TestGenerator {
	return &TestGenerator{}
}

// Name returns the generator name.
func (g *TestGenerator) Name() string {
	return "typescript-tests"
}

// Generate produces Vitest test files from the IR.
func (g *TestGenerator) Generate(i *ir.IR) (*codegen.Output, error) {
	output := codegen.NewOutput()

	// Generate test files for usecases
	for _, comp := range i.Components {
		if comp.Kind == ir.KindUsecase && comp.Usecase != nil {
			testCode := g.generateUsecaseTest(i, comp)
			output.AddFile(usecaseTestPath(comp.ID), []byte(testCode))
		}
	}

	// Generate test files for middlewares
	for _, comp := range i.Components {
		if comp.Kind == ir.KindMiddleware && comp.Middleware != nil {
			testCode := g.generateMiddlewareTest(comp)
			output.AddFile(middlewareTestPath(comp.ID), []byte(testCode))
		}
	}

	// Generate test files for servers
	for _, comp := range i.Components {
		if comp.Kind == ir.KindHTTPServer && comp.HTTPServer != nil {
			testCode := g.generateServerTest(i, comp)
			output.AddFile(serverTestPath(comp.ID), []byte(testCode))
		}
	}

	// Generate vitest setup file
	output.AddFile("src/test/setup.ts", []byte(g.generateTestSetup()))

	return output, nil
}

func (g *TestGenerator) generateUsecaseTest(i *ir.IR, uc *ir.Component) string {
	var sb strings.Builder

	funcName := toFunctionName(uc.ID)
	filename := sanitizeFilename(uc.ID)
	var server *ir.Component
	if uc.Usecase != nil && uc.Usecase.Binding != nil {
		server = i.Components[uc.Usecase.Binding.ServerID]
	}
	hasAuth := false
	for _, mwID := range effectiveUsecaseMiddleware(uc, server) {
		for _, key := range middlewareContextKeys(i, mwID) {
			if key == "auth" {
				hasAuth = true
				break
			}
		}
		if hasAuth {
			break
		}
	}

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { describe, it, expect, vi, beforeEach } from 'vitest';\n")
	sb.WriteString(fmt.Sprintf("import { %s } from './%s.usecase';\n", funcName, filename))
	sb.WriteString("import { createMockContext } from '../test/setup';\n\n")

	sb.WriteString(fmt.Sprintf("describe('%s', () => {\n", funcName))

	// Setup
	sb.WriteString("  let mockCtx: ReturnType<typeof createMockContext>;\n\n")
	sb.WriteString("  beforeEach(() => {\n")
	sb.WriteString("    mockCtx = createMockContext();\n")
	sb.WriteString("    vi.clearAllMocks();\n")
	sb.WriteString("  });\n\n")

	// Test: should be a function
	sb.WriteString("  it('should be a function', () => {\n")
	sb.WriteString(fmt.Sprintf("    expect(typeof %s).toBe('function');\n", funcName))
	sb.WriteString("  });\n\n")

	// Test: should return a promise
	sb.WriteString("  it('should return a promise', () => {\n")
	sb.WriteString("    // given\n")
	sb.WriteString("    const input = {};\n\n")
	sb.WriteString("    // when\n")
	sb.WriteString(fmt.Sprintf("    const result = %s(input as any, mockCtx);\n\n", funcName))
	sb.WriteString("    // then\n")
	sb.WriteString("    expect(result).toBeInstanceOf(Promise);\n")
	sb.WriteString("  });\n\n")

	// Test: should throw NotImplemented by default
	sb.WriteString("  it('should throw NotImplemented error by default', async () => {\n")
	sb.WriteString("    // given\n")
	sb.WriteString("    const input = {};\n\n")
	sb.WriteString("    // when/then\n")
	sb.WriteString(fmt.Sprintf("    await expect(%s(input as any, mockCtx)).rejects.toThrow('Not implemented');\n", funcName))
	sb.WriteString("  });\n\n")

	// Generate path param test if usecase has path params
	if uc.Usecase.Binding != nil {
		pathParams := extractPathParams(uc.Usecase.Binding.Path)
		if len(pathParams) > 0 {
			sb.WriteString("  it('should accept path parameters in input', async () => {\n")
			sb.WriteString("    // given\n")
			sb.WriteString("    const input = {\n")
			for _, param := range pathParams {
				sb.WriteString(fmt.Sprintf("      %s: 'test-%s',\n", param, param))
			}
			sb.WriteString("    };\n\n")
			sb.WriteString("    // when/then - should accept input shape without type error\n")
			sb.WriteString(fmt.Sprintf("    await expect(%s(input as any, mockCtx)).rejects.toThrow('Not implemented');\n", funcName))
			sb.WriteString("  });\n\n")
		}
	}

	// Test for auth context if auth middleware is required
	if hasAuth {
		sb.WriteString("  it('should have access to auth context', async () => {\n")
		sb.WriteString("    // given\n")
		sb.WriteString("    const input = {};\n")
		sb.WriteString("    const ctxWithAuth = {\n")
		sb.WriteString("      ...mockCtx,\n")
		sb.WriteString("      auth: { userId: 'user-123', session: {} },\n")
		sb.WriteString("    };\n\n")
		sb.WriteString("    // when/then - context should include auth\n")
		sb.WriteString("    expect(ctxWithAuth.auth).toBeDefined();\n")
		sb.WriteString("    expect(ctxWithAuth.auth.userId).toBe('user-123');\n")
		sb.WriteString("  });\n\n")
	}

	sb.WriteString("});\n")

	return sb.String()
}

func (g *TestGenerator) generateMiddlewareTest(mw *ir.Component) string {
	var sb strings.Builder

	funcName := toCamelCase(mw.ID) + "Middleware"
	filename := sanitizeFilename(mw.ID)

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { describe, it, expect, vi, beforeEach } from 'vitest';\n")
	sb.WriteString(fmt.Sprintf("import { %s } from './%s.middleware';\n\n", funcName, filename))

	sb.WriteString(fmt.Sprintf("describe('%s', () => {\n", funcName))

	// Test: should be a middleware function (created by createMiddleware)
	sb.WriteString("  it('should be a middleware function', () => {\n")
	sb.WriteString(fmt.Sprintf("    expect(typeof %s).toBe('function');\n", funcName))
	sb.WriteString("  });\n\n")

	// Provider-specific tests
	if mw.Middleware != nil {
		switch mw.Middleware.Provider {
		case "better-auth":
			sb.WriteString("  it('should set auth in context when session is valid', async () => {\n")
			sb.WriteString("    // given\n")
			sb.WriteString("    const mockHeaders = new Headers();\n")
			sb.WriteString("    mockHeaders.set('Authorization', 'Bearer valid-token');\n")
			sb.WriteString("    const mockCtx = {\n")
			sb.WriteString("      set: vi.fn(),\n")
			sb.WriteString("      req: {\n")
			sb.WriteString("        raw: { headers: mockHeaders },\n")
			sb.WriteString("        header: vi.fn().mockReturnValue('Bearer valid-token'),\n")
			sb.WriteString("      },\n")
			sb.WriteString("    };\n")
			sb.WriteString("    const mockNext = vi.fn().mockResolvedValue(undefined);\n\n")
			sb.WriteString("    // when\n")
			sb.WriteString(fmt.Sprintf("    await %s(mockCtx as any, mockNext);\n\n", funcName))
			sb.WriteString("    // then - middleware should call next and set auth context\n")
			sb.WriteString("    expect(mockNext).toHaveBeenCalled();\n")
			sb.WriteString("    expect(mockCtx.set).toHaveBeenCalledWith('auth', expect.any(Object));\n")
			sb.WriteString("  });\n\n")

		case "casbin":
			sb.WriteString("  it('should check authorization using enforcer', async () => {\n")
			sb.WriteString("    // given\n")
			sb.WriteString("    const mockCtx = {\n")
			sb.WriteString("      set: vi.fn(),\n")
			sb.WriteString("      get: vi.fn().mockReturnValue({ userId: 'user-123' }),\n")
			sb.WriteString("      req: { method: 'GET', path: '/users' },\n")
			sb.WriteString("    };\n")
			sb.WriteString("    const mockNext = vi.fn().mockResolvedValue(undefined);\n\n")
			sb.WriteString("    // when\n")
			sb.WriteString(fmt.Sprintf("    await %s(mockCtx as any, mockNext);\n\n", funcName))
			sb.WriteString("    // then - middleware should call next\n")
			sb.WriteString("    expect(mockNext).toHaveBeenCalled();\n")
			sb.WriteString("  });\n\n")
		}
	}

	sb.WriteString("});\n")

	return sb.String()
}

func (g *TestGenerator) generateServerTest(i *ir.IR, server *ir.Component) string {
	var sb strings.Builder

	filename := sanitizeFilename(server.ID)
	createAppName := "create" + toPascalCase(server.ID) + "App"

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { describe, it, expect, vi, beforeEach } from 'vitest';\n")
	sb.WriteString(fmt.Sprintf("import { %s } from './%s.server';\n", createAppName, filename))
	sb.WriteString(fmt.Sprintf("import type { ServerContext } from './%s.context';\n\n", filename))

	sb.WriteString(fmt.Sprintf("describe('%s', () => {\n", createAppName))

	// Test: should create Hono app
	sb.WriteString("  it('should create a Hono app instance', () => {\n")
	sb.WriteString("    // given\n")
	sb.WriteString("    const mockDeps = createMockDeps();\n\n")
	sb.WriteString("    // when\n")
	sb.WriteString(fmt.Sprintf("    const app = %s(mockDeps);\n\n", createAppName))
	sb.WriteString("    // then\n")
	sb.WriteString("    expect(app).toBeDefined();\n")
	sb.WriteString("    expect(typeof app.fetch).toBe('function');\n")
	sb.WriteString("  });\n\n")

	// Collect usecases bound to this server
	var boundUsecases []*ir.Component
	for _, comp := range i.Components {
		if comp.Kind == ir.KindUsecase && comp.Usecase != nil && comp.Usecase.Binding != nil {
			if comp.Usecase.Binding.ServerID == server.ID {
				boundUsecases = append(boundUsecases, comp)
			}
		}
	}
	sort.Slice(boundUsecases, func(i, j int) bool {
		return boundUsecases[i].ID < boundUsecases[j].ID
	})

	// Generate route tests for each bound usecase
	for _, uc := range boundUsecases {
		method := strings.ToUpper(uc.Usecase.Binding.Method)
		path := convertPathParams(uc.Usecase.Binding.Path)
		testPath := path
		// Replace :param with test values
		pathParams := extractPathParams(uc.Usecase.Binding.Path)
		for _, param := range pathParams {
			testPath = strings.Replace(testPath, ":"+param, "test-"+param, 1)
		}

		sb.WriteString(fmt.Sprintf("  it('should have %s %s route', async () => {\n", method, path))
		sb.WriteString("    // given\n")
		sb.WriteString("    const mockDeps = createMockDeps();\n")
		sb.WriteString(fmt.Sprintf("    const app = %s(mockDeps);\n\n", createAppName))
		sb.WriteString("    // when\n")
		sb.WriteString(fmt.Sprintf("    const req = new Request('http://localhost%s', {\n", testPath))
		sb.WriteString(fmt.Sprintf("      method: '%s',\n", method))
		if method == "POST" || method == "PUT" || method == "PATCH" {
			sb.WriteString("      headers: { 'Content-Type': 'application/json' },\n")
			sb.WriteString("      body: JSON.stringify({}),\n")
		}
		sb.WriteString("    });\n")
		sb.WriteString("    const res = await app.fetch(req);\n\n")
		sb.WriteString("    // then - route should exist (may return error from unimplemented usecase)\n")
		sb.WriteString("    expect(res.status).not.toBe(404);\n")
		sb.WriteString("  });\n\n")
	}

	// Helper function for mock deps - imports ServerContext for typing
	sb.WriteString("});\n\n")
	sb.WriteString("function createMockDeps(): ServerContext {\n")
	sb.WriteString("  return {\n")
	if len(getServerPostgresDependencies(i, server)) > 0 {
		sb.WriteString("    db: {\n")
		sb.WriteString("      query: {},\n")
		sb.WriteString("      insert: vi.fn(),\n")
		sb.WriteString("      update: vi.fn(),\n")
		sb.WriteString("      delete: vi.fn(),\n")
		sb.WriteString("    } as any,\n")
	}

	// Add auth/enforcer mocks based on middleware requirements
	hasAuth := false
	hasEnforcer := false
	for _, mwID := range collectServerMiddleware(i, server) {
		for _, key := range middlewareContextKeys(i, mwID) {
			switch key {
			case "auth":
				hasAuth = true
			case "enforcer":
				hasEnforcer = true
			}
		}
	}
	if hasAuth {
		sb.WriteString("    auth: { session: null, user: null } as any,\n")
	}
	if hasEnforcer {
		sb.WriteString("    enforcer: { enforce: vi.fn().mockResolvedValue(true) } as any,\n")
	}

	sb.WriteString("  };\n")
	sb.WriteString("}\n")

	return sb.String()
}

func (g *TestGenerator) generateTestSetup() string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("// Vitest test setup and utilities\n\n")
	sb.WriteString("import { vi } from 'vitest';\n\n")

	// Add global error handler for expected "Not implemented" errors
	sb.WriteString("// Suppress expected 'Not implemented' errors from usecase stubs\n")
	sb.WriteString("// These are expected when testing route existence before implementation\n")
	sb.WriteString("const originalUnhandledRejection = process.listeners('unhandledRejection');\n")
	sb.WriteString("process.removeAllListeners('unhandledRejection');\n")
	sb.WriteString("process.on('unhandledRejection', (error: any) => {\n")
	sb.WriteString("  if (error?.message === 'Not implemented') {\n")
	sb.WriteString("    // Expected from usecase stubs, ignore\n")
	sb.WriteString("    return;\n")
	sb.WriteString("  }\n")
	sb.WriteString("  // Re-throw other unhandled rejections\n")
	sb.WriteString("  originalUnhandledRejection.forEach(listener => {\n")
	sb.WriteString("    if (typeof listener === 'function') listener(error, Promise.reject(error));\n")
	sb.WriteString("  });\n")
	sb.WriteString("});\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Creates a mock context for testing usecases.\n")
	sb.WriteString(" * Includes mocked db, auth, and enforcer.\n")
	sb.WriteString(" * Cast as any to allow use with different ContextWith<K> types.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function createMockContext(): any {\n")
	sb.WriteString("  return {\n")
	sb.WriteString("    db: {\n")
	sb.WriteString("      query: {},\n")
	sb.WriteString("      insert: vi.fn().mockReturnValue({ values: vi.fn().mockReturnValue({ returning: vi.fn() }) }),\n")
	sb.WriteString("      update: vi.fn().mockReturnValue({ set: vi.fn().mockReturnValue({ where: vi.fn() }) }),\n")
	sb.WriteString("      delete: vi.fn().mockReturnValue({ where: vi.fn() }),\n")
	sb.WriteString("    },\n")
	sb.WriteString("    auth: { session: null, user: null },\n")
	sb.WriteString("    enforcer: {\n")
	sb.WriteString("      enforce: vi.fn().mockResolvedValue(true),\n")
	sb.WriteString("      addPolicy: vi.fn().mockResolvedValue(true),\n")
	sb.WriteString("      removePolicy: vi.fn().mockResolvedValue(true),\n")
	sb.WriteString("    },\n")
	sb.WriteString("  };\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Creates a mock Hono context for testing middleware.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function createMockHonoContext(overrides = {}) {\n")
	sb.WriteString("  const variables: Record<string, unknown> = {};\n")
	sb.WriteString("  return {\n")
	sb.WriteString("    req: {\n")
	sb.WriteString("      method: 'GET',\n")
	sb.WriteString("      path: '/',\n")
	sb.WriteString("      header: vi.fn().mockReturnValue(null),\n")
	sb.WriteString("      json: vi.fn().mockResolvedValue({}),\n")
	sb.WriteString("      param: vi.fn().mockReturnValue({}),\n")
	sb.WriteString("      query: vi.fn().mockReturnValue({}),\n")
	sb.WriteString("    },\n")
	sb.WriteString("    res: undefined,\n")
	sb.WriteString("    set: vi.fn((key: string, value: unknown) => { variables[key] = value; }),\n")
	sb.WriteString("    get: vi.fn((key: string) => variables[key]),\n")
	sb.WriteString("    json: vi.fn(),\n")
	sb.WriteString("    text: vi.fn(),\n")
	sb.WriteString("    status: vi.fn(),\n")
	sb.WriteString("    header: vi.fn(),\n")
	sb.WriteString("    ...overrides,\n")
	sb.WriteString("  };\n")
	sb.WriteString("}\n")

	return sb.String()
}
