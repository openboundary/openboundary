// Copyright 2026 Open Boundary Contributors
// SPDX-License-Identifier: AGPL-3.0-or-later

package typescript

import (
	"fmt"
	"sort"
	"strings"

	"github.com/openboundary/openboundary/internal/codegen"
	"github.com/openboundary/openboundary/internal/ir"
)

// OpenAPIGenerator generates a complete OpenAPI spec for orval type generation.
type OpenAPIGenerator struct{}

// NewOpenAPIGenerator creates a new OpenAPI generator.
func NewOpenAPIGenerator() *OpenAPIGenerator {
	return &OpenAPIGenerator{}
}

// Name returns the generator name.
func (g *OpenAPIGenerator) Name() string {
	return "typescript-openapi"
}

// Generate produces a complete OpenAPI spec from the IR.
// OpenAPI specs are colocated with their server components.
func (g *OpenAPIGenerator) Generate(i *ir.IR) (*codegen.Output, error) {
	output := codegen.NewOutput()

	// Generate OpenAPI spec colocated with each HTTP server
	for _, comp := range i.Components {
		if comp.Kind == ir.KindHTTPServer && comp.HTTPServer != nil {
			spec := g.generateOpenAPISpec(i, comp)
			output.AddFile(serverOpenAPIPath(comp.ID), []byte(spec))
		}
	}

	return output, nil
}

func (g *OpenAPIGenerator) generateOpenAPISpec(i *ir.IR, server *ir.Component) string {
	var sb strings.Builder

	// Get title/version from parsed OpenAPI if available
	title := "API"
	version := "0.0.1"
	if server.HTTPServer.ParsedOpenAPI != nil {
		if server.HTTPServer.ParsedOpenAPI.Title != "" {
			title = server.HTTPServer.ParsedOpenAPI.Title
		}
		if server.HTTPServer.ParsedOpenAPI.Version != "" {
			version = server.HTTPServer.ParsedOpenAPI.Version
		}
	}

	sb.WriteString("# Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("openapi: 3.0.3\n")
	sb.WriteString("info:\n")
	sb.WriteString(fmt.Sprintf("  title: %s\n", title))
	sb.WriteString(fmt.Sprintf("  version: %s\n", version))
	sb.WriteString("paths:\n")

	// Collect all usecases bound to this server, grouped by path
	pathOps := make(map[string][]*ir.Component)
	for _, comp := range i.Components {
		if comp.Kind == ir.KindUsecase && comp.Usecase != nil && comp.Usecase.Binding != nil {
			if comp.Usecase.Binding.ServerID == server.ID {
				path := comp.Usecase.Binding.Path
				pathOps[path] = append(pathOps[path], comp)
			}
		}
	}

	// Sort paths for deterministic output
	paths := make([]string, 0, len(pathOps))
	for path := range pathOps {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	for _, path := range paths {
		ops := pathOps[path]
		sb.WriteString(fmt.Sprintf("  %s:\n", path))

		// Extract path parameters once for this path
		pathParams := extractPathParams(path)

		// Sort operations by method for deterministic output
		sort.Slice(ops, func(i, j int) bool {
			return ops[i].Usecase.Binding.Method < ops[j].Usecase.Binding.Method
		})

		for _, uc := range ops {
			method := strings.ToLower(uc.Usecase.Binding.Method)
			sb.WriteString(fmt.Sprintf("    %s:\n", method))

			// Operation ID from OpenAPI or generate from usecase
			operationID := ""
			if uc.Usecase.Binding.Operation != nil && uc.Usecase.Binding.Operation.OperationID != "" {
				operationID = uc.Usecase.Binding.Operation.OperationID
			} else {
				operationID = toFunctionName(uc.ID)
			}
			sb.WriteString(fmt.Sprintf("      operationId: %s\n", operationID))

			// Summary from goal
			if uc.Usecase.Goal != "" {
				sb.WriteString(fmt.Sprintf("      summary: %s\n", uc.Usecase.Goal))
			}

			// Tags
			sb.WriteString("      tags:\n")
			sb.WriteString(fmt.Sprintf("        - %s\n", server.ID))

			// Parameters
			if len(pathParams) > 0 {
				sb.WriteString("      parameters:\n")
				for _, param := range pathParams {
					sb.WriteString(fmt.Sprintf("        - name: %s\n", param))
					sb.WriteString("          in: path\n")
					sb.WriteString("          required: true\n")
					sb.WriteString("          schema:\n")
					sb.WriteString("            type: string\n")
				}
			}

			// Request body for POST/PUT/PATCH
			if method == "post" || method == "put" || method == "patch" {
				sb.WriteString("      requestBody:\n")
				sb.WriteString("        required: true\n")
				sb.WriteString("        content:\n")
				sb.WriteString("          application/json:\n")
				sb.WriteString("            schema:\n")
				sb.WriteString(fmt.Sprintf("              $ref: '#/components/schemas/%sRequest'\n", toPascalCase(operationID)))
			}

			// Responses
			sb.WriteString("      responses:\n")
			statusCode := g.getSuccessStatus(method)
			sb.WriteString(fmt.Sprintf("        '%s':\n", statusCode))
			sb.WriteString(fmt.Sprintf("          description: %s\n", g.getStatusDescription(statusCode)))

			if statusCode != "204" {
				sb.WriteString("          content:\n")
				sb.WriteString("            application/json:\n")
				sb.WriteString("              schema:\n")
				sb.WriteString(fmt.Sprintf("                $ref: '#/components/schemas/%sResponse'\n", toPascalCase(operationID)))
			}
		}
	}

	// Generate component schemas
	sb.WriteString("components:\n")
	sb.WriteString("  schemas:\n")

	// Generate request/response schemas for each operation
	for _, path := range paths {
		for _, uc := range pathOps[path] {
			method := strings.ToLower(uc.Usecase.Binding.Method)
			operationID := ""
			if uc.Usecase.Binding.Operation != nil && uc.Usecase.Binding.Operation.OperationID != "" {
				operationID = uc.Usecase.Binding.Operation.OperationID
			} else {
				operationID = toFunctionName(uc.ID)
			}
			pascalID := toPascalCase(operationID)

			// Request schema for POST/PUT/PATCH
			if method == "post" || method == "put" || method == "patch" {
				sb.WriteString(fmt.Sprintf("    %sRequest:\n", pascalID))
				sb.WriteString("      type: object\n")
				sb.WriteString("      properties:\n")
				sb.WriteString("        # TODO: Define request properties\n")
				sb.WriteString("        data:\n")
				sb.WriteString("          type: object\n")
			}

			// Response schema (except for 204)
			if g.getSuccessStatus(method) != "204" {
				sb.WriteString(fmt.Sprintf("    %sResponse:\n", pascalID))
				sb.WriteString("      type: object\n")
				sb.WriteString("      properties:\n")
				sb.WriteString("        # TODO: Define response properties\n")
				sb.WriteString("        data:\n")
				sb.WriteString("          type: object\n")
			}
		}
	}

	return sb.String()
}

func (g *OpenAPIGenerator) getSuccessStatus(method string) string {
	switch method {
	case "post":
		return "201"
	case "delete":
		return "204"
	default:
		return "200"
	}
}

func (g *OpenAPIGenerator) getStatusDescription(status string) string {
	switch status {
	case "200":
		return "OK"
	case "201":
		return "Created"
	case "204":
		return "No Content"
	default:
		return "Success"
	}
}
