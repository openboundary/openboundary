// Copyright 2026 Open Boundary Contributors
// SPDX-License-Identifier: AGPL-3.0-or-later

package typescript

import (
	"fmt"
	"strings"

	"github.com/openboundary/openboundary/internal/codegen"
	"github.com/openboundary/openboundary/internal/ir"
)

// E2ETestGenerator generates Playwright E2E tests for HTTP servers.
type E2ETestGenerator struct{}

// NewE2ETestGenerator creates a new E2E test generator.
func NewE2ETestGenerator() *E2ETestGenerator {
	return &E2ETestGenerator{}
}

// Name returns the generator name.
func (g *E2ETestGenerator) Name() string {
	return "typescript-e2e"
}

// Generate produces E2E test files from the IR.
func (g *E2ETestGenerator) Generate(i *ir.IR) (*codegen.Output, error) {
	output := codegen.NewOutput()

	// Generate E2E test file for each HTTP server
	for _, comp := range i.Components {
		if comp.Kind == ir.KindHTTPServer && comp.HTTPServer != nil {
			testCode := g.generateServerE2ETest(i, comp)
			filename := fmt.Sprintf("e2e/%s.spec.ts", sanitizeFilename(comp.ID))
			output.AddFile(filename, []byte(testCode))
		}
	}

	// Generate Playwright configuration
	playwrightConfig := g.generatePlaywrightConfig(i)
	output.AddFile("playwright.config.ts", []byte(playwrightConfig))

	// Generate E2E test helpers
	setupHelpers := g.generateE2ESetup(i)
	output.AddFile("e2e/helpers/setup.ts", []byte(setupHelpers))

	return output, nil
}

func (g *E2ETestGenerator) generateServerE2ETest(i *ir.IR, server *ir.Component) string {
	var sb strings.Builder

	serverID := server.ID

	// Determine base URL
	port := 3000
	if server.HTTPServer.Port > 0 {
		port = server.HTTPServer.Port
	}
	baseURL := fmt.Sprintf("http://localhost:%d", port)

	// Get usecases bound to this server
	usecases := getUsecasesBoundToServer(i, serverID)

	// Check if server has auth middleware
	hasAuth := false
	for _, mwID := range collectServerMiddleware(i, server) {
		for _, key := range middlewareContextKeys(i, mwID) {
			if key == "auth" {
				hasAuth = true
				break
			}
		}
		if hasAuth {
			break
		}
	}

	// Header
	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { test, expect } from '@playwright/test';\n")
	if hasAuth {
		sb.WriteString("import { createAuthToken } from './helpers/setup';\n")
	}
	sb.WriteString("\n")

	sb.WriteString(fmt.Sprintf("const baseURL = '%s';\n\n", baseURL))

	sb.WriteString(fmt.Sprintf("test.describe('%s API', () => {\n", serverID))

	// Health check test
	sb.WriteString("  test('GET /health - health check', async ({ request }) => {\n")
	sb.WriteString("    const response = await request.get(`${baseURL}/health`);\n")
	sb.WriteString("    expect(response.status()).toBe(200);\n")
	sb.WriteString("  });\n\n")

	// Generate tests for each usecase
	for _, uc := range usecases {
		if uc.Usecase == nil || uc.Usecase.Binding == nil {
			continue
		}

		binding := uc.Usecase.Binding
		method := strings.ToUpper(binding.Method)
		path := binding.Path

		// Convert path params from {id} to test values
		testPath := path
		pathParams := extractPathParams(path)
		for _, param := range pathParams {
			testPath = strings.Replace(testPath, "{"+param+"}", "test-"+param, 1)
		}

		// Check if usecase requires auth
		ucHasAuth := false
		for _, mwID := range effectiveUsecaseMiddleware(uc, server) {
			for _, key := range middlewareContextKeys(i, mwID) {
				if key == "auth" {
					ucHasAuth = true
					break
				}
			}
			if ucHasAuth {
				break
			}
		}

		// Generate test name
		testName := fmt.Sprintf("%s %s", method, path)

		sb.WriteString(fmt.Sprintf("  test('%s - endpoint exists', async ({ request }) => {\n", testName))

		// Setup auth if needed
		if ucHasAuth {
			sb.WriteString("    const token = createAuthToken({ userId: 'test-user' });\n")
			sb.WriteString("    const headers = { Authorization: `Bearer ${token}` };\n\n")
		}

		// Make request
		sb.WriteString("    const response = await request.")
		sb.WriteString(strings.ToLower(method))
		sb.WriteString("(`${baseURL}")
		sb.WriteString(testPath)
		sb.WriteString("`")

		// Add request options
		if method == "POST" || method == "PUT" || method == "PATCH" {
			sb.WriteString(", {\n")
			if ucHasAuth {
				sb.WriteString("      headers,\n")
			}
			sb.WriteString("      data: {},\n")
			sb.WriteString("    }")
		} else if ucHasAuth {
			sb.WriteString(", { headers }")
		}

		sb.WriteString(");\n\n")

		// Assertion - should not be 404 (route exists, may return error from unimplemented usecase)
		sb.WriteString("    // Route should exist (may return error from unimplemented usecase)\n")
		sb.WriteString("    expect(response.status()).not.toBe(404);\n")
		sb.WriteString("  });\n\n")
	}

	sb.WriteString("});\n")

	return sb.String()
}

func (g *E2ETestGenerator) generatePlaywrightConfig(i *ir.IR) string {
	var sb strings.Builder

	// Get port from first server
	port := 3000
	for _, comp := range i.Components {
		if comp.Kind == ir.KindHTTPServer && comp.HTTPServer != nil {
			if comp.HTTPServer.Port > 0 {
				port = comp.HTTPServer.Port
			}
			break
		}
	}

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { defineConfig, devices } from '@playwright/test';\n\n")

	sb.WriteString("export default defineConfig({\n")
	sb.WriteString("  testDir: './e2e',\n")
	sb.WriteString("  fullyParallel: true,\n")
	sb.WriteString("  forbidOnly: !!process.env.CI,\n")
	sb.WriteString("  retries: process.env.CI ? 2 : 0,\n")
	sb.WriteString("  workers: process.env.CI ? 1 : undefined,\n")
	sb.WriteString("  reporter: 'html',\n")
	sb.WriteString("  use: {\n")
	sb.WriteString(fmt.Sprintf("    baseURL: process.env.BASE_URL || 'http://localhost:%d',\n", port))
	sb.WriteString("    trace: 'on-first-retry',\n")
	sb.WriteString("  },\n")
	sb.WriteString("  projects: [\n")
	sb.WriteString("    {\n")
	sb.WriteString("      name: 'API Tests',\n")
	sb.WriteString("      use: { ...devices['Desktop Chrome'] },\n")
	sb.WriteString("    },\n")
	sb.WriteString("  ],\n")
	sb.WriteString("  webServer: {\n")
	sb.WriteString("    command: 'npm run dev',\n")
	sb.WriteString(fmt.Sprintf("    url: 'http://localhost:%d/health',\n", port))
	sb.WriteString("    reuseExistingServer: !process.env.CI,\n")
	sb.WriteString("    timeout: 120 * 1000,\n")
	sb.WriteString("  },\n")
	sb.WriteString("});\n")

	return sb.String()
}

func (g *E2ETestGenerator) generateE2ESetup(i *ir.IR) string {
	var sb strings.Builder

	// Check if any server has auth middleware
	hasAuth := false
	for _, comp := range i.Components {
		if comp.Kind == ir.KindHTTPServer && comp.HTTPServer != nil {
			for _, mwID := range collectServerMiddleware(i, comp) {
				for _, key := range middlewareContextKeys(i, mwID) {
					if key == "auth" {
						hasAuth = true
						break
					}
				}
				if hasAuth {
					break
				}
			}
		}
		if hasAuth {
			break
		}
	}

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("// E2E test helpers and setup utilities\n\n")

	if hasAuth {
		sb.WriteString("/**\n")
		sb.WriteString(" * Creates a mock authentication token for testing.\n")
		sb.WriteString(" * In production, integrate with your actual auth provider.\n")
		sb.WriteString(" */\n")
		sb.WriteString("export function createAuthToken(payload: { userId: string }): string {\n")
		sb.WriteString("  // TODO: Implement actual token creation based on your auth provider\n")
		sb.WriteString("  // For now, return a mock token\n")
		sb.WriteString("  return 'mock-token-' + payload.userId;\n")
		sb.WriteString("}\n\n")
	}

	sb.WriteString("/**\n")
	sb.WriteString(" * Creates test data for API endpoints.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function createTestData(type: string): Record<string, unknown> {\n")
	sb.WriteString("  const timestamp = Date.now();\n")
	sb.WriteString("  \n")
	sb.WriteString("  switch (type) {\n")
	sb.WriteString("    case 'user':\n")
	sb.WriteString("      return {\n")
	sb.WriteString("        email: `test-${timestamp}@example.com`,\n")
	sb.WriteString("        name: `Test User ${timestamp}`,\n")
	sb.WriteString("      };\n")
	sb.WriteString("    default:\n")
	sb.WriteString("      return {};\n")
	sb.WriteString("  }\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Waits for a condition to be true.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export async function waitForCondition(\n")
	sb.WriteString("  condition: () => Promise<boolean>,\n")
	sb.WriteString("  timeout = 5000,\n")
	sb.WriteString("  interval = 100\n")
	sb.WriteString("): Promise<void> {\n")
	sb.WriteString("  const start = Date.now();\n")
	sb.WriteString("  while (Date.now() - start < timeout) {\n")
	sb.WriteString("    if (await condition()) {\n")
	sb.WriteString("      return;\n")
	sb.WriteString("    }\n")
	sb.WriteString("    await new Promise((resolve) => setTimeout(resolve, interval));\n")
	sb.WriteString("  }\n")
	sb.WriteString("  throw new Error('Condition not met within timeout');\n")
	sb.WriteString("}\n")

	return sb.String()
}
