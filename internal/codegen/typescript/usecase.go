// Copyright 2026 OpenBoundary Contributors
// SPDX-License-Identifier: AGPL-3.0-or-later

package typescript

import (
	"fmt"
	"sort"
	"strings"

	"github.com/openboundary/openboundary/internal/codegen"
	"github.com/openboundary/openboundary/internal/ir"
)

// UsecaseGenerator generates TypeScript usecase files.
type UsecaseGenerator struct{}

// NewUsecaseGenerator creates a new usecase generator.
func NewUsecaseGenerator() *UsecaseGenerator {
	return &UsecaseGenerator{}
}

// Name returns the generator name.
func (g *UsecaseGenerator) Name() string {
	return "typescript-usecase"
}

// Generate produces usecase files from the IR.
func (g *UsecaseGenerator) Generate(i *ir.IR) (*codegen.Output, error) {
	output := codegen.NewOutput()

	// Generate usecase files for each usecase component
	for _, comp := range i.Components {
		if comp.Kind != ir.KindUsecase || comp.Usecase == nil {
			continue
		}

		// Types file: always regenerated
		typesCode := g.generateUsecaseTypes(i, comp)
		output.AddComponentFile(usecaseTypesPath(comp.ID), []byte(typesCode), comp.ID)

		// Implementation file: written once, never overwritten
		implCode := g.generateUsecaseImpl(i, comp)
		output.AddWriteOnceComponentFile(usecaseSourcePath(comp.ID), []byte(implCode), comp.ID)
	}

	// Generate index file that exports all usecases
	indexCode := g.generateIndex(i)
	output.AddFile(usecaseIndexPath(), []byte(indexCode))

	return output, nil
}

// generateUsecaseTypes produces the *.usecase.types.ts file (always regenerated).
func (g *UsecaseGenerator) generateUsecaseTypes(i *ir.IR, uc *ir.Component) string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")

	// Determine which server this usecase is bound to
	var server *ir.Component
	if uc.Usecase.Binding != nil {
		server = i.Components[uc.Usecase.Binding.ServerID]
	}

	// Import context type from the server (colocated with servers)
	if server != nil {
		sb.WriteString(fmt.Sprintf("import type { ContextWith } from './%s.context';\n",
			componentIDSlug(server.ID)))
	}

	// Determine type names based on OpenAPI operation
	funcName := toFunctionName(uc.ID)
	typeName := toPascalCase(funcName) + "UsecaseFn"
	operationID := ""
	method := ""
	if uc.Usecase.Binding != nil {
		method = strings.ToLower(uc.Usecase.Binding.Method)
		if uc.Usecase.Binding.Operation != nil && uc.Usecase.Binding.Operation.OperationID != "" {
			operationID = uc.Usecase.Binding.Operation.OperationID
		}
	}

	// Build imports from Orval-generated schemas
	schemaImports := []string{}
	inputTypeName := "void"
	outputTypeName := "void"

	if operationID != "" {
		pascalOp := toPascalCase(operationID)

		// Request type for POST/PUT/PATCH
		if method == "post" || method == "put" || method == "patch" {
			inputTypeName = pascalOp + "Request"
			schemaImports = append(schemaImports, inputTypeName)
		}

		// Response type (except for 204 No Content)
		if method != "delete" {
			outputTypeName = pascalOp + "Response"
			schemaImports = append(schemaImports, outputTypeName)
		}
	}

	// Add path params to input type
	pathParams := []string{}
	if uc.Usecase.Binding != nil {
		pathParams = extractPathParams(uc.Usecase.Binding.Path)
	}

	// Import from Orval schemas (colocated with usecases)
	if len(schemaImports) > 0 {
		sb.WriteString(fmt.Sprintf("import type { %s } from './usecase.schemas';\n", strings.Join(schemaImports, ", ")))
	}
	sb.WriteString("\n")

	// Generate combined input type if we have path params
	if len(pathParams) > 0 {
		localInputTypeName := toPascalCase(funcName) + "Input"
		if inputTypeName != "void" {
			// Combine path params with request body
			sb.WriteString("/** Input combining path params and request body */\n")
			sb.WriteString(fmt.Sprintf("export interface %s extends %s {\n", localInputTypeName, inputTypeName))
		} else {
			sb.WriteString("/** Input with path parameters */\n")
			sb.WriteString(fmt.Sprintf("export interface %s {\n", localInputTypeName))
		}
		for _, param := range pathParams {
			sb.WriteString(fmt.Sprintf("  %s: string;\n", param))
		}
		sb.WriteString("}\n\n")
		inputTypeName = localInputTypeName
	}

	// Generate JSDoc with usecase metadata
	sb.WriteString("/**\n")
	sb.WriteString(fmt.Sprintf(" * %s\n", uc.Usecase.Goal))
	sb.WriteString(" *\n")

	if uc.Usecase.Actor != "" {
		sb.WriteString(fmt.Sprintf(" * @actor %s\n", uc.Usecase.Actor))
	}

	if len(uc.Usecase.Preconditions) > 0 {
		sb.WriteString(" *\n * Preconditions:\n")
		for _, pre := range uc.Usecase.Preconditions {
			sb.WriteString(fmt.Sprintf(" * - %s\n", pre))
		}
	}

	if len(uc.Usecase.AcceptanceCriteria) > 0 {
		sb.WriteString(" *\n * Acceptance Criteria:\n")
		for _, ac := range uc.Usecase.AcceptanceCriteria {
			sb.WriteString(fmt.Sprintf(" * - %s\n", ac))
		}
	}

	if len(uc.Usecase.Postconditions) > 0 {
		sb.WriteString(" *\n * Postconditions:\n")
		for _, post := range uc.Usecase.Postconditions {
			sb.WriteString(fmt.Sprintf(" * - %s\n", post))
		}
	}

	sb.WriteString(" */\n")

	// Generate context type based on usecase needs
	contextFields := contextFieldsForUsecase(i, uc, server)
	contextType := g.contextTypeForFields(contextFields)

	// Generate the function type alias
	sb.WriteString(fmt.Sprintf("export type %s = (\n", typeName))
	sb.WriteString(fmt.Sprintf("  input: %s,\n", inputTypeName))
	sb.WriteString(fmt.Sprintf("  ctx: %s\n", contextType))
	sb.WriteString(fmt.Sprintf(") => Promise<%s>;\n", outputTypeName))

	return sb.String()
}

// generateUsecaseImpl produces the *.usecase.ts file (written once, never overwritten).
func (g *UsecaseGenerator) generateUsecaseImpl(_ *ir.IR, uc *ir.Component) string {
	var sb strings.Builder

	funcName := toFunctionName(uc.ID)
	typeName := toPascalCase(funcName) + "UsecaseFn"
	slug := componentIDSlug(uc.ID)

	sb.WriteString("// Generated by OpenBoundary\n")
	sb.WriteString("// Implement the function body below. This file will not be overwritten.\n\n")

	sb.WriteString(fmt.Sprintf("import type { %s } from './%s.usecase.types';\n\n", typeName, slug))

	sb.WriteString(fmt.Sprintf("export const %s: %s = async (input, ctx) => {\n", funcName, typeName))
	sb.WriteString("  // TODO: Implement usecase\n")
	sb.WriteString("  throw new Error('Not implemented');\n")
	sb.WriteString("};\n")

	return sb.String()
}

func (g *UsecaseGenerator) contextTypeForFields(fields []string) string {
	if len(fields) == 0 {
		return "ContextWith<never>"
	}

	quoted := make([]string, 0, len(fields))
	for _, field := range fields {
		quoted = append(quoted, fmt.Sprintf("'%s'", field))
	}

	if len(quoted) == 1 {
		return fmt.Sprintf("ContextWith<%s>", quoted[0])
	}

	return fmt.Sprintf("ContextWith<%s>", strings.Join(quoted, " | "))
}

func (g *UsecaseGenerator) generateIndex(i *ir.IR) string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("// Re-exports all usecases for convenient importing\n\n")

	// Collect and sort usecases for deterministic output
	var usecases []*ir.Component
	for _, comp := range i.Components {
		if comp.Kind == ir.KindUsecase && comp.Usecase != nil {
			usecases = append(usecases, comp)
		}
	}
	sort.Slice(usecases, func(i, j int) bool {
		return usecases[i].ID < usecases[j].ID
	})

	// Generate exports
	for _, uc := range usecases {
		funcName := toFunctionName(uc.ID)
		sb.WriteString(fmt.Sprintf("export { %s } from './%s.usecase';\n", funcName, componentIDSlug(uc.ID)))
	}

	return sb.String()
}
