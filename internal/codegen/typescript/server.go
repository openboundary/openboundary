// Package typescript provides TypeScript code generation.
package typescript

import (
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/openboundary/openboundary/internal/codegen"
	"github.com/openboundary/openboundary/internal/ir"
)

// HonoServerGenerator generates Hono server code.
type HonoServerGenerator struct{}

// NewHonoServerGenerator creates a new Hono server generator.
func NewHonoServerGenerator() *HonoServerGenerator {
	return &HonoServerGenerator{}
}

// Name returns the generator name.
func (g *HonoServerGenerator) Name() string {
	return "typescript-hono"
}

// Generate produces Hono server code from the IR.
func (g *HonoServerGenerator) Generate(i *ir.IR) (*codegen.Output, error) {
	output := codegen.NewOutput()

	// Generate server files for each http.server component
	for _, comp := range i.Components {
		if comp.Kind != ir.KindHTTPServer || comp.HTTPServer == nil {
			continue
		}

		// Generate the server file
		serverCode := g.generateServer(i, comp)
		filename := fmt.Sprintf("src/components/servers/%s.ts", sanitizeFilename(comp.ID))
		output.AddFile(filename, []byte(serverCode))
	}

	// Generate main index.ts that wires everything
	indexCode := g.generateIndex(i)
	output.AddFile("src/index.ts", []byte(indexCode))

	// Generate middleware files
	for _, comp := range i.Components {
		if comp.Kind != ir.KindMiddleware || comp.Middleware == nil {
			continue
		}

		mwCode := g.generateMiddleware(comp)
		if mwCode != "" {
			filename := fmt.Sprintf("src/components/middlewares/%s.ts", sanitizeFilename(comp.ID))
			output.AddFile(filename, []byte(mwCode))
		}

		// Generate additional files for better-auth
		if comp.Middleware.Provider == "better-auth" {
			// Find the postgres dependency
			pgID := ""
			for _, depID := range comp.Middleware.DependsOn {
				if dep, ok := i.Components[depID]; ok && dep.Kind == ir.KindPostgres {
					pgID = dep.ID
					break
				}
			}
			if pgID == "" {
				// Fallback: find first postgres component
				for _, c := range i.Components {
					if c.Kind == ir.KindPostgres {
						pgID = c.ID
						break
					}
				}
			}

			// Generate auth config
			configCode := g.generateBetterAuthConfig(comp, pgID)
			configFilename := fmt.Sprintf("src/components/middlewares/%s.config.ts", sanitizeFilename(comp.ID))
			output.AddFile(configFilename, []byte(configCode))

			// Generate auth schema
			schemaCode := g.generateBetterAuthSchema()
			schemaFilename := fmt.Sprintf("src/components/middlewares/%s.schema.ts", sanitizeFilename(comp.ID))
			output.AddFile(schemaFilename, []byte(schemaCode))
		}
	}

	// Generate postgres client if needed
	for _, comp := range i.Components {
		if comp.Kind != ir.KindPostgres || comp.Postgres == nil {
			continue
		}

		pgCode := g.generatePostgresClient(comp)
		filename := fmt.Sprintf("src/components/postgres/%s.ts", sanitizeFilename(comp.ID))
		output.AddFile(filename, []byte(pgCode))
	}

	// Generate postgres client type file
	output.AddFile("src/components/postgres/client.ts", []byte(postgresClientType))

	return output, nil
}

func (g *HonoServerGenerator) generateServer(i *ir.IR, server *ir.Component) string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { Hono } from 'hono';\n")

	// Collect usecases bound to this server
	usecases := getUsecasesBoundToServer(i, server.ID)
	middlewareRefs := collectServerMiddleware(i, server)

	// Import context type (colocated with server)
	sb.WriteString(fmt.Sprintf("import type { ServerContext } from './%s.context';\n", sanitizeFilename(server.ID)))

	// Import middlewares
	for _, mwRef := range middlewareRefs {
		sb.WriteString(fmt.Sprintf("import { %sMiddleware } from '../middlewares/%s';\n",
			toCamelCase(mwRef), sanitizeFilename(mwRef)))
	}

	// Import usecases
	for _, uc := range usecases {
		sb.WriteString(fmt.Sprintf("import { %s } from '../usecases/%s';\n",
			toFunctionName(uc.ID), sanitizeFilename(uc.ID)))
	}

	sb.WriteString("\n")
	// Middleware matrix (route -> requirements)
	g.writeMiddlewareMatrix(&sb, server, usecases, middlewareRefs)

	// Define Hono env type
	sb.WriteString("type Env = {\n")
	sb.WriteString("  Variables: ServerContext;\n")
	sb.WriteString("};\n\n")

	// Generate createApp function
	createAppName := "create" + toPascalCase(server.ID) + "App"
	sb.WriteString(fmt.Sprintf("/**\n * Creates the %s Hono application.\n", server.ID))
	sb.WriteString(" * @param ctx - The server context with dependencies\n */\n")
	sb.WriteString(fmt.Sprintf("export function %s(ctx: ServerContext): Hono<Env> {\n", createAppName))
	sb.WriteString("  const app = new Hono<Env>();\n\n")

	// Apply base context middleware
	sb.WriteString("  // Set base context from dependencies\n")
	sb.WriteString("  app.use('*', async (c, next) => {\n")

	// Set context fields from dependencies
	if len(getServerPostgresDependencies(i, server)) > 0 {
		sb.WriteString("    c.set('db', ctx.db);\n")
	}

	sb.WriteString("    await next();\n")
	sb.WriteString("  });\n\n")

	// Apply server-level middleware only when required by the route
	if len(middlewareRefs) > 0 {
		sb.WriteString("  // Apply server-level middleware only when required by the route\n")
		for _, mwRef := range middlewareRefs {
			sb.WriteString("  app.use('*', async (c, next) => {\n")
			sb.WriteString(fmt.Sprintf("    if (!routeRequiresMiddleware(%s, c.req.method, c.req.path)) {\n", strconv.Quote(mwRef)))
			sb.WriteString("      return next();\n")
			sb.WriteString("    }\n")
			sb.WriteString(fmt.Sprintf("    return %sMiddleware(c, next);\n", toCamelCase(mwRef)))
			sb.WriteString("  });\n")
		}
		sb.WriteString("\n")
	}

	// Generate routes for each usecase
	sb.WriteString("  // Route handlers\n")
	for _, uc := range usecases {
		g.generateRoute(&sb, i, uc, server)
	}

	sb.WriteString("\n  return app;\n")
	sb.WriteString("}\n")

	return sb.String()
}

func (g *HonoServerGenerator) generateRoute(sb *strings.Builder, i *ir.IR, uc *ir.Component, server *ir.Component) {
	if uc.Usecase == nil || uc.Usecase.Binding == nil {
		return
	}

	binding := uc.Usecase.Binding
	method := strings.ToLower(binding.Method)
	path := binding.Path
	funcName := toFunctionName(uc.ID)

	// Convert path params from {id} to :id for Hono
	honoPath := convertPathParams(path)

	sb.WriteString(fmt.Sprintf("\n  // %s - %s\n", uc.ID, uc.Usecase.Goal))

	// Routes rely on the middleware matrix for execution
	sb.WriteString(fmt.Sprintf("  app.%s('%s', async (c) => {\n", method, honoPath))

	// Extract path parameters
	pathParams := extractPathParams(path)
	if len(pathParams) > 0 {
		for _, param := range pathParams {
			sb.WriteString(fmt.Sprintf("    const %s = c.req.param('%s');\n", param, param))
		}
	}

	// Parse request body for methods that have one
	if method == "post" || method == "put" || method == "patch" {
		sb.WriteString("    const body = await c.req.json();\n")
	}

	// Determine if we need an input object
	hasBody := method == "post" || method == "put" || method == "patch"
	hasInput := len(pathParams) > 0 || hasBody

	// Build input object (only if needed)
	if hasInput {
		sb.WriteString("    const input = {\n")
		for _, param := range pathParams {
			sb.WriteString(fmt.Sprintf("      %s,\n", param))
		}
		if hasBody {
			sb.WriteString("      ...body,\n")
		}
		sb.WriteString("    };\n\n")
	}

	// Build context for usecase
	contextFields := contextFieldsForUsecase(i, uc, server)
	if len(contextFields) == 0 {
		sb.WriteString("    const context = {};\n\n")
	} else {
		sb.WriteString("    const context = {\n")
		for _, field := range contextFields {
			switch field {
			case "db":
				sb.WriteString("      db: c.get('db'),\n")
			case "auth":
				sb.WriteString("      auth: c.get('auth'),\n")
			case "enforcer":
				sb.WriteString("      enforcer: c.get('enforcer'),\n")
			}
		}
		sb.WriteString("    };\n\n")
	}

	// Call usecase
	if hasInput {
		sb.WriteString(fmt.Sprintf("    const result = await %s(input, context);\n", funcName))
	} else {
		sb.WriteString(fmt.Sprintf("    const result = await %s(undefined as void, context);\n", funcName))
	}

	// Return response
	switch method {
	case "post":
		sb.WriteString("    return c.json(result, 201);\n")
	case "delete":
		sb.WriteString("    return c.body(null, 204);\n")
	default:
		sb.WriteString("    return c.json(result);\n")
	}

	sb.WriteString("  });\n")
}

func (g *HonoServerGenerator) generateIndex(i *ir.IR) string {
	var sb strings.Builder

	// Check if we have better-auth middleware
	var betterAuthMw *ir.Component
	for _, comp := range i.Components {
		if comp.Kind == ir.KindMiddleware && comp.Middleware != nil && comp.Middleware.Provider == "better-auth" {
			betterAuthMw = comp
			break
		}
	}

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { serve } from '@hono/node-server';\n")

	// Import Hono and cors if we have better-auth (need to mount auth routes)
	if betterAuthMw != nil {
		sb.WriteString("import { Hono } from 'hono';\n")
		sb.WriteString("import { cors } from 'hono/cors';\n")
		sb.WriteString(fmt.Sprintf("import { auth } from './components/middlewares/%s.config';\n",
			sanitizeFilename(betterAuthMw.ID)))
	}

	// Import server creators
	servers := g.getHTTPServers(i)
	for _, server := range servers {
		sb.WriteString(fmt.Sprintf("import { create%sApp } from './components/servers/%s';\n",
			toPascalCase(server.ID), sanitizeFilename(server.ID)))
	}

	// Import postgres clients
	for _, comp := range i.Components {
		if comp.Kind == ir.KindPostgres && comp.Postgres != nil {
			sb.WriteString(fmt.Sprintf("import { create%sClient } from './components/postgres/%s';\n",
				toPascalCase(comp.ID), sanitizeFilename(comp.ID)))
		}
	}

	sb.WriteString("\nasync function main() {\n")
	sb.WriteString("  // Initialize dependencies\n")

	// Initialize postgres clients
	for _, comp := range i.Components {
		if comp.Kind == ir.KindPostgres && comp.Postgres != nil {
			varName := toCamelCase(comp.ID) + "Client"
			sb.WriteString(fmt.Sprintf("  const %s = await create%sClient();\n", varName, toPascalCase(comp.ID)))
		}
	}

	sb.WriteString("\n")

	// Create and start servers
	for _, server := range servers {
		middlewareRefs := collectServerMiddleware(i, server)
		port := server.HTTPServer.Port
		if port == 0 {
			port = 3000
		}

		sb.WriteString(fmt.Sprintf("  // Start %s\n", server.ID))
		sb.WriteString("  const context = {\n")

		// Add dependencies to context
		for _, dep := range getServerPostgresDependencies(i, server) {
			sb.WriteString(fmt.Sprintf("    db: %sClient,\n", toCamelCase(dep.ID)))
		}

		// Add null for middleware context (will be set by middleware)
		hasAuth := false
		hasEnforcer := false
		for _, mwRef := range middlewareRefs {
			for _, key := range middlewareContextKeys(i, mwRef) {
				switch key {
				case "auth":
					hasAuth = true
				case "enforcer":
					hasEnforcer = true
				}
			}
		}
		if hasAuth {
			sb.WriteString("    auth: null,\n")
		}
		if hasEnforcer {
			sb.WriteString("    enforcer: null,\n")
		}

		sb.WriteString("  };\n\n")

		appVar := toCamelCase(server.ID) + "App"
		sb.WriteString(fmt.Sprintf("  const %s = create%sApp(context);\n", appVar, toPascalCase(server.ID)))

		// If we have better-auth, create a root app that mounts auth routes
		if betterAuthMw != nil {
			sb.WriteString("\n  // Create root app with auth routes\n")
			sb.WriteString("  const app = new Hono();\n\n")
			sb.WriteString("  // CORS for auth routes\n")
			sb.WriteString("  app.use('/api/auth/*', cors({\n")
			sb.WriteString("    origin: process.env.CORS_ORIGIN || 'http://localhost:3000',\n")
			sb.WriteString("    allowHeaders: ['Content-Type', 'Authorization'],\n")
			sb.WriteString("    allowMethods: ['POST', 'GET', 'OPTIONS'],\n")
			sb.WriteString("    credentials: true,\n")
			sb.WriteString("  }));\n\n")
			sb.WriteString("  // Mount better-auth routes\n")
			sb.WriteString("  app.on(['POST', 'GET'], '/api/auth/*', (c) => auth.handler(c.req.raw));\n\n")
			sb.WriteString(fmt.Sprintf("  // Mount API routes\n  app.route('/', %s);\n\n", appVar))
			sb.WriteString(fmt.Sprintf("  serve({ fetch: app.fetch, port: %d }, (info) => {\n", port))
		} else {
			sb.WriteString(fmt.Sprintf("  serve({ fetch: %s.fetch, port: %d }, (info) => {\n", appVar, port))
		}

		sb.WriteString(fmt.Sprintf("    console.log(`%s listening on http://localhost:${info.port}`);\n", server.ID))
		sb.WriteString("  });\n")
	}

	sb.WriteString("}\n\n")
	sb.WriteString("main().catch(console.error);\n")

	return sb.String()
}

func (g *HonoServerGenerator) generateMiddleware(mw *ir.Component) string {
	if mw.Middleware == nil {
		return ""
	}

	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { createMiddleware } from 'hono/factory';\n")

	switch mw.Middleware.Provider {
	case "better-auth":
		mwFilename := sanitizeFilename(mw.ID)
		sb.WriteString(fmt.Sprintf("import { auth, type Session, type User } from './%s.config';\n\n", mwFilename))
		sb.WriteString(fmt.Sprintf("export const %sMiddleware = createMiddleware(async (c, next) => {\n", toCamelCase(mw.ID)))
		sb.WriteString("  const session = await auth.api.getSession({ headers: c.req.raw.headers });\n\n")
		sb.WriteString("  if (!session) {\n")
		sb.WriteString("    c.set('auth', { session: null, user: null });\n")
		sb.WriteString("  } else {\n")
		sb.WriteString("    c.set('auth', { session: session.session, user: session.user });\n")
		sb.WriteString("  }\n\n")
		sb.WriteString("  await next();\n")
		sb.WriteString("});\n\n")
		// Also export a requireAuth middleware
		sb.WriteString("/** Middleware that requires authentication - returns 401 if not authenticated */\n")
		sb.WriteString("export const requireAuth = createMiddleware(async (c, next) => {\n")
		sb.WriteString("  const authCtx = c.get('auth');\n\n")
		sb.WriteString("  if (!authCtx?.session || !authCtx?.user) {\n")
		sb.WriteString("    return c.json({ error: 'Unauthorized' }, 401);\n")
		sb.WriteString("  }\n\n")
		sb.WriteString("  await next();\n")
		sb.WriteString("});\n")

	case "casbin":
		// Config files are colocated with middleware (paths from project root)
		mwFilename := sanitizeFilename(mw.ID)
		sb.WriteString("import { newEnforcer, Enforcer } from 'casbin';\n")
		sb.WriteString("import path from 'path';\n")
		sb.WriteString("import { fileURLToPath } from 'url';\n\n")
		sb.WriteString("const __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n")
		sb.WriteString("let enforcer: Enforcer | null = null;\n\n")
		sb.WriteString("async function getEnforcer(): Promise<Enforcer> {\n")
		sb.WriteString("  if (!enforcer) {\n")
		sb.WriteString(fmt.Sprintf("    const modelPath = path.join(__dirname, '%s.model.conf');\n", mwFilename))
		sb.WriteString(fmt.Sprintf("    const policyPath = path.join(__dirname, '%s.policy.csv');\n", mwFilename))
		sb.WriteString("    enforcer = await newEnforcer(modelPath, policyPath);\n")
		sb.WriteString("  }\n")
		sb.WriteString("  return enforcer;\n")
		sb.WriteString("}\n\n")
		sb.WriteString(fmt.Sprintf("export const %sMiddleware = createMiddleware(async (c, next) => {\n", toCamelCase(mw.ID)))
		sb.WriteString("  const e = await getEnforcer();\n")
		sb.WriteString("  c.set('enforcer', e);\n")
		sb.WriteString("  // TODO: Implement authorization check\n")
		sb.WriteString("  // const auth = c.get('auth');\n")
		sb.WriteString("  // const allowed = await e.enforce(auth?.user?.id, c.req.path, c.req.method);\n")
		sb.WriteString("  await next();\n")
		sb.WriteString("});\n")

	default:
		return ""
	}

	return sb.String()
}

func (g *HonoServerGenerator) generatePostgresClient(pg *ir.Component) string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")

	if pg.Postgres.Provider == "drizzle" {
		sb.WriteString("import { drizzle } from 'drizzle-orm/postgres-js';\n")
		sb.WriteString("import postgres from 'postgres';\n")
		// Import from the colocated schema file
		sb.WriteString(fmt.Sprintf("import * as schema from './%s.schema';\n\n", sanitizeFilename(pg.ID)))

		sb.WriteString("// Database connection\n")
		sb.WriteString("const connectionString = process.env.DATABASE_URL || '';\n")
		sb.WriteString("const client = postgres(connectionString);\n\n")

		sb.WriteString("// Export db instance for use by auth and other modules\n")
		sb.WriteString("export const db = drizzle(client, { schema });\n\n")

		sb.WriteString("// Factory function for explicit initialization with validation\n")
		sb.WriteString(fmt.Sprintf("export async function create%sClient() {\n", toPascalCase(pg.ID)))
		sb.WriteString("  if (!connectionString) {\n")
		sb.WriteString("    throw new Error('DATABASE_URL environment variable is required');\n")
		sb.WriteString("  }\n")
		sb.WriteString("  return db;\n")
		sb.WriteString("}\n")
	}

	return sb.String()
}

func (g *HonoServerGenerator) getHTTPServers(i *ir.IR) []*ir.Component {
	var servers []*ir.Component
	for _, comp := range i.Components {
		if comp.Kind == ir.KindHTTPServer && comp.HTTPServer != nil {
			servers = append(servers, comp)
		}
	}
	sort.Slice(servers, func(i, j int) bool {
		return servers[i].ID < servers[j].ID
	})
	return servers
}

// Helper functions

type routeRequirement struct {
	method       string
	regexLiteral string
}

func (g *HonoServerGenerator) writeMiddlewareMatrix(sb *strings.Builder, server *ir.Component, usecases []*ir.Component, middlewareRefs []string) {
	if len(middlewareRefs) == 0 {
		return
	}

	sb.WriteString("type MiddlewareRoute = { method: string; path: RegExp };\n")
	sb.WriteString("const middlewareMatrix: Record<string, MiddlewareRoute[]> = {\n")
	for _, mwID := range middlewareRefs {
		routes := g.collectRoutesForMiddleware(usecases, server, mwID)
		sb.WriteString(fmt.Sprintf("  %s: [\n", strconv.Quote(mwID)))
		for _, route := range routes {
			sb.WriteString(fmt.Sprintf("    { method: '%s', path: %s },\n", route.method, route.regexLiteral))
		}
		sb.WriteString("  ],\n")
	}
	sb.WriteString("};\n\n")

	sb.WriteString("function routeRequiresMiddleware(mwId: string, method: string, path: string): boolean {\n")
	sb.WriteString("  const routes = middlewareMatrix[mwId];\n")
	sb.WriteString("  if (!routes || routes.length === 0) return false;\n")
	sb.WriteString("  for (const route of routes) {\n")
	sb.WriteString("    if (route.method === method && route.path.test(path)) {\n")
	sb.WriteString("      return true;\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")
	sb.WriteString("  return false;\n")
	sb.WriteString("}\n\n")
}

func (g *HonoServerGenerator) collectRoutesForMiddleware(usecases []*ir.Component, server *ir.Component, mwID string) []routeRequirement {
	var routes []routeRequirement
	for _, uc := range usecases {
		if uc.Usecase == nil || uc.Usecase.Binding == nil {
			continue
		}
		if !stringInSlice(mwID, effectiveUsecaseMiddleware(uc, server)) {
			continue
		}
		method := strings.ToUpper(uc.Usecase.Binding.Method)
		honoPath := convertPathParams(uc.Usecase.Binding.Path)
		routes = append(routes, routeRequirement{
			method:       method,
			regexLiteral: honoPathToRegexLiteral(honoPath),
		})
	}
	return routes
}

// titleCase capitalizes the first letter of a string.
// This replaces the deprecated strings.Title for simple single-word cases.
func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func toCamelCase(s string) string {
	parts := strings.Split(s, ".")
	for i, part := range parts {
		if i == 0 {
			parts[i] = strings.ToLower(part)
		} else {
			parts[i] = titleCase(part)
		}
	}
	result := strings.Join(parts, "")
	result = strings.ReplaceAll(result, "-", "")
	return result
}

func toPascalCase(s string) string {
	parts := strings.Split(s, ".")
	for i, part := range parts {
		parts[i] = titleCase(part)
	}
	result := strings.Join(parts, "")
	result = strings.ReplaceAll(result, "-", "")
	return result
}

func toFunctionName(usecaseID string) string {
	// usecase.create-user -> createUserUsecase
	parts := strings.Split(usecaseID, ".")
	if len(parts) < 2 {
		return toCamelCase(usecaseID) + "Usecase"
	}

	name := parts[len(parts)-1] // e.g., "create-user"
	nameParts := strings.Split(name, "-")
	for i, p := range nameParts {
		if i == 0 {
			nameParts[i] = strings.ToLower(p)
		} else {
			nameParts[i] = titleCase(p)
		}
	}
	return strings.Join(nameParts, "") + "Usecase"
}

func convertPathParams(path string) string {
	// Convert {id} to :id for Hono
	result := path
	for {
		start := strings.Index(result, "{")
		if start == -1 {
			break
		}
		end := strings.Index(result, "}")
		if end == -1 {
			break
		}
		param := result[start+1 : end]
		result = result[:start] + ":" + param + result[end+1:]
	}
	return result
}

func honoPathToRegexLiteral(path string) string {
	segments := strings.Split(path, "/")
	for i, segment := range segments {
		if strings.HasPrefix(segment, ":") && len(segment) > 1 {
			segments[i] = "[^/]+"
			continue
		}
		segments[i] = regexp.QuoteMeta(segment)
	}
	pattern := "^" + strings.Join(segments, "/") + "$"
	return fmt.Sprintf("new RegExp(%s)", strconv.Quote(pattern))
}

func stringInSlice(value string, items []string) bool {
	for _, item := range items {
		if item == value {
			return true
		}
	}
	return false
}

func extractPathParams(path string) []string {
	var params []string
	for {
		start := strings.Index(path, "{")
		if start == -1 {
			break
		}
		end := strings.Index(path, "}")
		if end == -1 {
			break
		}
		params = append(params, path[start+1:end])
		path = path[end+1:]
	}
	return params
}

// generateBetterAuthConfig generates the better-auth configuration file.
func (g *HonoServerGenerator) generateBetterAuthConfig(mw *ir.Component, pgID string) string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("import { betterAuth } from 'better-auth';\n")
	sb.WriteString("import { drizzleAdapter } from 'better-auth/adapters/drizzle';\n")
	sb.WriteString(fmt.Sprintf("import { db } from '../postgres/%s';\n", sanitizeFilename(pgID)))
	sb.WriteString(fmt.Sprintf("import * as authSchema from './%s.schema';\n\n", sanitizeFilename(mw.ID)))

	sb.WriteString("export const auth = betterAuth({\n")
	sb.WriteString("  database: drizzleAdapter(db, {\n")
	sb.WriteString("    provider: 'pg',\n")
	sb.WriteString("    schema: authSchema,\n")
	sb.WriteString("  }),\n")
	sb.WriteString("  emailAndPassword: {\n")
	sb.WriteString("    enabled: true,\n")
	sb.WriteString("    minPasswordLength: 8,\n")
	sb.WriteString("    maxPasswordLength: 128,\n")
	sb.WriteString("  },\n")
	sb.WriteString("  session: {\n")
	sb.WriteString("    expiresIn: 60 * 60 * 24 * 7, // 7 days\n")
	sb.WriteString("    updateAge: 60 * 60 * 24,     // 1 day\n")
	sb.WriteString("  },\n")
	sb.WriteString("});\n\n")

	sb.WriteString("// Export inferred types for use in middleware and usecases\n")
	sb.WriteString("export type Session = typeof auth.$Infer.Session.session;\n")
	sb.WriteString("export type User = typeof auth.$Infer.Session.user;\n")

	return sb.String()
}

// generateBetterAuthSchema generates the Drizzle schema for better-auth tables.
func (g *HonoServerGenerator) generateBetterAuthSchema() string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n")
	sb.WriteString("// Better-auth required schema tables\n")
	sb.WriteString("import { pgTable, text, timestamp, boolean } from 'drizzle-orm/pg-core';\n\n")

	// User table
	sb.WriteString("export const user = pgTable('user', {\n")
	sb.WriteString("  id: text('id').primaryKey(),\n")
	sb.WriteString("  name: text('name').notNull(),\n")
	sb.WriteString("  email: text('email').notNull().unique(),\n")
	sb.WriteString("  emailVerified: boolean('email_verified').notNull().default(false),\n")
	sb.WriteString("  image: text('image'),\n")
	sb.WriteString("  createdAt: timestamp('created_at').notNull().defaultNow(),\n")
	sb.WriteString("  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n")
	sb.WriteString("});\n\n")

	// Session table
	sb.WriteString("export const session = pgTable('session', {\n")
	sb.WriteString("  id: text('id').primaryKey(),\n")
	sb.WriteString("  userId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),\n")
	sb.WriteString("  token: text('token').notNull().unique(),\n")
	sb.WriteString("  expiresAt: timestamp('expires_at').notNull(),\n")
	sb.WriteString("  ipAddress: text('ip_address'),\n")
	sb.WriteString("  userAgent: text('user_agent'),\n")
	sb.WriteString("  createdAt: timestamp('created_at').notNull().defaultNow(),\n")
	sb.WriteString("  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n")
	sb.WriteString("});\n\n")

	// Account table (stores credentials)
	sb.WriteString("export const account = pgTable('account', {\n")
	sb.WriteString("  id: text('id').primaryKey(),\n")
	sb.WriteString("  userId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),\n")
	sb.WriteString("  accountId: text('account_id').notNull(),\n")
	sb.WriteString("  providerId: text('provider_id').notNull(),\n")
	sb.WriteString("  accessToken: text('access_token'),\n")
	sb.WriteString("  refreshToken: text('refresh_token'),\n")
	sb.WriteString("  accessTokenExpiresAt: timestamp('access_token_expires_at'),\n")
	sb.WriteString("  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),\n")
	sb.WriteString("  scope: text('scope'),\n")
	sb.WriteString("  idToken: text('id_token'),\n")
	sb.WriteString("  password: text('password'),\n")
	sb.WriteString("  createdAt: timestamp('created_at').notNull().defaultNow(),\n")
	sb.WriteString("  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n")
	sb.WriteString("});\n\n")

	// Verification table
	sb.WriteString("export const verification = pgTable('verification', {\n")
	sb.WriteString("  id: text('id').primaryKey(),\n")
	sb.WriteString("  identifier: text('identifier').notNull(),\n")
	sb.WriteString("  value: text('value').notNull(),\n")
	sb.WriteString("  expiresAt: timestamp('expires_at').notNull(),\n")
	sb.WriteString("  createdAt: timestamp('created_at').notNull().defaultNow(),\n")
	sb.WriteString("  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n")
	sb.WriteString("});\n")

	return sb.String()
}

const postgresClientType = `// Generated by OpenBoundary - DO NOT EDIT
import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type DrizzleClient = PostgresJsDatabase<any>;
`
