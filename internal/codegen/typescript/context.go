// Copyright 2026 Open Boundary Contributors
// SPDX-License-Identifier: AGPL-3.0-or-later

package typescript

import (
	"fmt"
	"sort"
	"strings"

	"github.com/openboundary/openboundary/internal/codegen"
	"github.com/openboundary/openboundary/internal/ir"
)

// ContextGenerator generates TypeScript context type definitions.
type ContextGenerator struct{}

// NewContextGenerator creates a new context generator.
func NewContextGenerator() *ContextGenerator {
	return &ContextGenerator{}
}

// Name returns the generator name.
func (g *ContextGenerator) Name() string {
	return "typescript-context"
}

// Generate produces context type definitions.
func (g *ContextGenerator) Generate(i *ir.IR) (*codegen.Output, error) {
	output := codegen.NewOutput()

	// Generate context types colocated with each http.server
	for _, comp := range i.Components {
		if comp.Kind != ir.KindHTTPServer || comp.HTTPServer == nil {
			continue
		}

		contextFile := g.generateServerContext(i, comp)
		output.AddComponentFile(serverContextPath(comp.ID), []byte(contextFile), comp.ID)
	}

	return output, nil
}

func (g *ContextGenerator) generateServerContext(i *ir.IR, server *ir.Component) string {
	var sb strings.Builder

	sb.WriteString("// Generated by OpenBoundary - DO NOT EDIT\n\n")

	// Collect imports based on dependencies
	imports := g.collectImports(i, server)
	for _, imp := range imports {
		sb.WriteString(imp)
		sb.WriteString("\n")
	}
	if len(imports) > 0 {
		sb.WriteString("\n")
	}

	// Generate the context interface
	sb.WriteString(fmt.Sprintf("/**\n * Context for %s\n", server.ID))
	sb.WriteString(" * Contains all dependencies and middleware-provided values.\n */\n")
	sb.WriteString("export interface ServerContext {\n")

	// Add database dependencies
	for _, dep := range getServerPostgresDependencies(i, server) {
		if dep.Postgres != nil {
			fieldName := g.extractFieldName(dep.ID, "db")
			sb.WriteString(fmt.Sprintf("  /** Database client from %s */\n", dep.ID))
			sb.WriteString(fmt.Sprintf("  %s: DrizzleClient;\n", fieldName))
		}
	}

	// Add middleware dependencies (from server and bound usecases)
	for _, mwRef := range collectServerMiddleware(i, server) {
		mwComp, ok := i.Components[mwRef]
		if !ok || mwComp.Middleware == nil {
			continue
		}

		fieldName, fieldType := g.getMiddlewareContextField(mwComp)
		if fieldName != "" {
			sb.WriteString(fmt.Sprintf("  /** Context from %s */\n", mwRef))
			sb.WriteString(fmt.Sprintf("  %s: %s;\n", fieldName, fieldType))
		}
	}

	sb.WriteString("}\n\n")

	// Generate helper type for extracting partial context
	sb.WriteString("/**\n * Pick specific fields from ServerContext.\n")
	sb.WriteString(" * Use this to type usecase context parameters.\n */\n")
	sb.WriteString("export type ContextWith<K extends keyof ServerContext> = Pick<ServerContext, K>;\n")

	return sb.String()
}

func (g *ContextGenerator) collectImports(i *ir.IR, server *ir.Component) []string {
	imports := make(map[string]bool)

	// Check for postgres dependencies
	for _, dep := range getServerPostgresDependencies(i, server) {
		if dep.Postgres != nil && dep.Postgres.Provider == "drizzle" {
			imports[fmt.Sprintf("import type { DrizzleClient } from '%s';", postgresClientImportPath())] = true
		}
	}

	// Check middleware
	for _, mwRef := range collectServerMiddleware(i, server) {
		mwComp, ok := i.Components[mwRef]
		if !ok || mwComp.Middleware == nil {
			continue
		}

		switch mwComp.Middleware.Provider {
		case "better-auth":
			// Import auth context type from the generated middleware module.
			imports[fmt.Sprintf(
				"import type { AuthContext as %s } from './%s.middleware';",
				g.betterAuthContextAlias(mwComp.ID),
				componentIDSlug(mwComp.ID),
			)] = true
		case "casbin":
			imports["import type { Enforcer } from 'casbin';"] = true
		}
	}

	// Sort imports for deterministic output
	result := make([]string, 0, len(imports))
	for imp := range imports {
		result = append(result, imp)
	}
	sort.Strings(result)
	return result
}

func (g *ContextGenerator) getMiddlewareContextField(mw *ir.Component) (name, typeDef string) {
	if mw.Middleware == nil {
		return "", ""
	}

	// Make middleware context fields optional (?) since they're populated at runtime
	switch mw.Middleware.Provider {
	case "better-auth":
		return "auth?", fmt.Sprintf("%s | null", g.betterAuthContextAlias(mw.ID))
	case "casbin":
		return "enforcer?", "Enforcer | null"
	default:
		return "", ""
	}
}

func (g *ContextGenerator) betterAuthContextAlias(componentID string) string {
	return toPascalCase(componentID) + "AuthContext"
}

func (g *ContextGenerator) extractFieldName(componentID, fallback string) string {
	// Extract a sensible field name from component ID
	// e.g., "postgres.primary" -> "db" or "primaryDb"
	parts := strings.Split(componentID, ".")
	if len(parts) > 1 {
		return fallback // Use fallback for simplicity
	}
	return fallback
}
